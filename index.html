<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>å³¶å¶¼å€™è»Šå®¤ï¼é–‹å¾€æ°‘ä¸»çš„è½‰å‹æ­£ç¾©åˆ—è»Š</title>
  <!-- Social / link preview -->
  <meta property="og:title" content="å³¶å¶¼å€™è»Šå®¤ï¼é–‹å¾€æ°‘ä¸»çš„è½‰å‹æ­£ç¾©åˆ—è»Š" />
  <meta property="og:description" content="åœ¨è»Šç«™å ´æ™¯ä¸­ï¼Œè·Ÿéš¨è§’è‰²ä¸€åŒå°‹æ‰¾è½‰å‹æ­£ç¾©çš„æ•…äº‹èˆ‡è¦‹è­‰é»ã€‚" />
  <meta property="og:image" content="assets/social_preview.png" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(180deg, #101318 0%, #05070a 100%);
      color: #111;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      min-height: 100vh;
      height: 100vh;
      height: 100dvh;
      width: 100%;
    }
    @media (min-width: 769px) {
      body {
        display: flex;
        justify-content: center;
        align-items: center;
      }
    }

    /* Desktop layout: large main card + two stacked side cards */
    .layout-desktop {
      width: 100%;
      max-width: 1280px;
      display: flex;
      gap: 24px;
      padding: 24px;
      box-sizing: border-box;
      height: 100vh;
      margin: 0 auto;
    }
    .layout-main {
      flex: 1 1 auto;
      min-width: 0;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      padding: 20px;
      box-sizing: border-box;
    }
    .game-canvas-wrap {
      width: 100%;
      height: 100%;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    canvas {
      border: none;
      background: #000;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: none;
    }
    /* (åŸ infoBox æ¨£å¼å·²åˆªé™¤ï¼Œä¸å†é¡¯ç¤ºç•«é¢æç¤ºæ¡†) */

    /* Popup (Modal) overlay: fullscreenï¼ŒRWD æ»¿ç‰ˆ */
    .popup-overlay {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      margin: 0;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 50;
    }
    .popup-overlay.hidden {
      display: none;
    }
    .popup-content {
      position: relative;
      background: #f4e9d7;
      padding: 16px 20px;
      padding-top: max(16px, env(safe-area-inset-top));
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      border-radius: 4px;
      width: min(96vw, 520px);
      max-width: 96vw;
      margin: 0 auto;
      max-height: min(80vh, 720px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
      border: 2px solid #c2b59b;
    }
    .popup-title {
      font-size: clamp(26px, 4.6vw, 34px); /* larger title like the image */
      margin: 0 0 16px 0;
      color: #003366; /* deep blue similar to info.png title */
      letter-spacing: 0.06em;
      font-weight: 700;
      padding-bottom: 6px;
      border-bottom: 2px solid #ffffff; /* clear white underline under the title */
    }
    .popup-body {
      font-size: clamp(12px, 1.9vw, 16px); /* slightly smaller to fit more text */
      line-height: 1.8;
      color: #333333;
    }
    .popup-body p {
      margin: 0 0 10px 0;
    }
    .popup-figure {
      float: right;
      margin: 0 0 8px 12px;
      text-align: center;
    }
    .popup-figure img {
      display: block;
      max-width: 140px;
      width: 100%;
      height: auto;
    }
    .popup-figure span {
      display: block;
      margin-top: 4px;
      font-size: 11px;
      color: #555;
    }
    @media (max-width: 600px) {
      .popup-figure {
        float: none;
        margin: 0 0 10px 0;
      }
    }
    .popup-close {
      position: absolute;
      top: 6px;
      right: 8px;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      border: 1px solid #666;
      background: #f4e9d7;
      color: #555;
      font-size: 18px;
      line-height: 1;
      padding: 0;
      cursor: pointer;
    }
    .popup-close:hover {
      background: #e2d6c1;
    }

    .controls {
      position: relative;
      margin-top: 8px;
      display: grid;
      grid-template-columns: 52px 52px 52px;
      grid-template-rows: 52px 52px 52px;
      gap: 6px;
      touch-action: none;
      user-select: none;
      justify-content: center;
      margin-bottom: 8px;
    }

    /* Desktop-only help button on the right side */
    .help-button-desktop {
      position: fixed;
      right: 16px;
      top: 16px;
      transform: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid #666;
      background: #333;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
      z-index: 30;
    }

    .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 29;
    }
    .help-overlay.hidden {
      display: none;
    }
    .help-content {
      max-width: 480px;
      max-height: 80vh;
      padding: 16px 20px;
      background: #f4f4f4;
      color: #222;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
      overflow-y: auto;
      font-size: 14px;
      line-height: 1.6;
    }
    .help-content h3 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 18px;
    }
    .help-close {
      margin-top: 12px;
      display: inline-block;
      padding: 6px 12px;
      background: #333;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    /* Experience start screen */
    .start-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }
    .start-overlay.hidden {
      display: none;
    }
    .start-card {
      max-width: 520px;
      padding: 20px 24px 18px;
      border-radius: 10px;
      background: #f4f4f4;
      color: #222;
      text-align: center;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.7);
    }
    .start-card h1 {
      margin: 0 0 10px 0;
      font-size: 20px;
      line-height: 1.6;
    }
    .start-card p {
      margin: 0 0 14px 0;
      font-size: 14px;
      line-height: 1.6;
    }
    .start-button {
      display: inline-block;
      padding: 8px 20px;
      border-radius: 18px;
      background: linear-gradient(to bottom, #f7f7f7 0%, #ffffff 70%);
      color: #222;
      font-size: 14px;
      cursor: pointer;
      border: 1px solid #ccc;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
    }
    .start-button:hover {
      background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 80%);
    }
    .btn {
      background: #444;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      border: 1px solid #666;
      color: #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
    }
    .btn.active {
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
      background: #777;
    }

    /* Global soft fade-in animation */
    @keyframes fade-in-soft {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Apply fade-in to main cards and key UI elements */
    body,
    .layout-desktop,
    .game-wrapper,
    .side-card,
    #infoBox,
    .controls,
    .start-overlay,
    .help-overlay,
    #popup {
      animation: fade-in-soft 0.7s ease-out both;
    }

    @media (max-width: 768px) {
      body {
        font-size: 16px;
      }
      #infoBox {
        font-size: 16px;
      }
      .popup-title {
        font-size: clamp(20px, 5.2vw, 26px);
      }
      .popup-body {
        font-size: 15px;
      }
      .start-card h1 {
        font-size: 18px;
      }
      .start-card p {
        font-size: 15px;
      }
      .help-content {
        font-size: 15px;
      }
      /* æ‰‹æ©Ÿç›´å‘ï¼šæ»¿ç‰ˆï¼Œç„¡å·¦å³é–“è· */
      .layout-desktop {
        flex-direction: column;
        padding: 0;
        margin: 0;
        width: 100%;
        max-width: 100%;
        height: 100vh;
        height: 100dvh;
      }
      .layout-side {
        display: none;
      }
      .layout-main {
        width: 100%;
        height: 100%;
        display: grid;
        grid-template-rows: 3.6fr 1fr;
        grid-template-columns: 1fr;
        justify-items: stretch;
        align-items: start;
        gap: 0;
        min-height: 0;
        padding: 0;
        padding-bottom: max(1.5vh, env(safe-area-inset-bottom, 0px));
        box-sizing: border-box;
        overflow: hidden;
      }
      .game-canvas-wrap {
        min-height: 0;
        width: 100%;
        max-width: 100vw;
      }
      canvas {
        border-radius: 18px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
      }
      #infoBox {
        position: absolute;
        left: 50%;
        bottom: 80px;
        transform: translateX(-50%);
        margin-top: 0;
        max-width: 90%;
      }
      .controls {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        margin: 0;
        padding-bottom: env(safe-area-inset-bottom, 0px);
        z-index: 20;
        grid-template-columns: 64px 64px 64px;
        grid-template-rows: 64px 64px 64px;
        gap: 8px;
        justify-content: center;
      }
      .controls::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 220px;
        height: 220px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.75);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.85);
        z-index: -1;
      }
      .btn {
        font-size: 24px;
      }

      /* Mobile: hide help button (no hamburger / question mark on phone) */
      .help-button-desktop {
        display: none;
      }
    }
    /* æ¡Œæ©Ÿç‰ˆï¼šCanvas ä¾é«˜åº¦ç¸®æ”¾ï¼Œå¯¬åº¦è‡ªå‹•è¨ˆç®—ï¼Œä¸åšæ°´å¹³æ‹‰ä¼¸ï¼›æ–¹å‘éµå›ºå®šåœ¨å³ä¸‹è§’ */
    @media (min-width: 769px) {
      .layout-desktop {
        max-width: 100%;
        height: 100vh;
      }
      .layout-main,
      .layout-side {
        height: 100%;
      }
      .game-wrapper {
        width: 100%;
        height: 100%;
        margin: 0;
      }
      .game-canvas-wrap {
        height: 90vh;
        width: 100%;
      }
      canvas {
        border-radius: 16px;
        overflow: hidden;
      }
      .controls {
        position: fixed;
        right: 40px;
        bottom: 40px;
        transform: none;
        margin: 0;
        z-index: 40;
        grid-template-columns: 52px 52px 52px;
        grid-template-rows: 52px 52px 52px;
        gap: 6px;
      }
      .controls::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 190px;
        height: 190px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.75);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.85);
        z-index: -1;
      }
    }

    /* æ‰‹æ©Ÿæ©«å‘ï¼šéŠæˆ²å¡«æ»¿é«˜åº¦ã€ä¸Šæ–¹è²¼é½Šï¼Œæ–¹å‘éµåœ¨ç•«é¢å³ä¸‹è§’ï¼Œéš±è— ? æŒ‰éˆ•ï¼›å³å´å¡ç‰‡ä¸é¡¯ç¤º */
    @media (max-width: 1024px) and (orientation: landscape) {
      .layout-desktop {
        flex-direction: column;
        padding: 0;
        height: 100vh;
        height: 100dvh;
      }
      .layout-side {
        display: none;
      }
      .layout-main {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        justify-content: flex-start;
        align-items: center;
        overflow: hidden;
      }
      .game-wrapper {
        height: 100vh;
        height: 100dvh;
        padding: 0;
        margin: 0;
        border-radius: 0;
        box-shadow: none;
        overflow: hidden;
      }
      .game-canvas-wrap {
        width: 100%;
        height: 100%;
        min-height: 0;
      }
      canvas {
        /* æ‰‹æ©Ÿæ©«å‘ï¼šç”± resizeCanvas + contain ç¹ªè£½ï¼Œä¸å¦ç”¨ CSS scale */
        margin: 0;
        display: block;
        border-radius: 18px;
        overflow: hidden;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
      }
      #infoBox {
        position: absolute;
        left: 50%;
        bottom: max(80px, env(safe-area-inset-bottom, 0px) + 80px);
        transform: translateX(-50%);
        margin-top: 0;
        max-width: 90%;
      }

      /* æ‰‹æ©Ÿæ©«å‘ï¼šè·³çª—æ¥è¿‘æ»¿ç‰ˆã€å¯æ²å‹• */
      .popup-content {
        width: min(96vw, 520px);
        max-width: 96vw;
        max-height: min(80vh, 720px);
      }
      .controls {
        /* æ‰‹æ©Ÿæ©«å‘ï¼šæ–¹å‘éµå›ºå®šåœ¨ç•«é¢å³ä¸‹è§’ */
        position: fixed;
        right: max(16px, env(safe-area-inset-right, 0px) + 12px);
        bottom: max(24px, env(safe-area-inset-bottom, 0px) + 16px);
        left: auto;
        transform: none;
        margin: 0;
        z-index: 30;
        grid-template-columns: 64px 64px 64px;
        grid-template-rows: 64px 64px 64px;
        gap: 8px;
      }
      .controls::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 220px;
        height: 220px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.75);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.85);
        z-index: -1;
      }

      /* Landscape mobile: hide help button */
      .help-button-desktop {
        display: none;
      }
    }

    /* ç›´å‘è¢å¹•ï¼ˆå«å¹³æ¿ï¼‰ï¼šæ»¿ç‰ˆã€ç„¡å·¦å³é–“è· */
    @media (max-width: 1024px) and (orientation: portrait) {
      .layout-desktop {
        height: 100vh;
        height: 100dvh;
        padding: 0;
        margin: 0;
        max-width: 100%;
      }
      .layout-main {
        width: 100%;
        height: 100%;
        display: grid;
        grid-template-rows: 2.8fr 1fr;
        grid-template-columns: 1fr;
        justify-items: stretch;
        align-items: start;
        gap: 0;
        min-height: 0;
        padding: 0;
        padding-bottom: max(1.5vh, env(safe-area-inset-bottom, 0px));
        box-sizing: border-box;
        overflow: hidden;
      }
      .controls {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        margin: 0;
        padding-bottom: env(safe-area-inset-bottom, 0px);
        z-index: 20;
        justify-content: center;
      }
      .controls::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 220px;
        height: 220px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.75);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.85);
        z-index: -1;
      }
    }
  </style>
</head>
<body>
  <div class="layout-desktop">
    <div class="layout-main">
      <div id="game-canvas-wrap" class="game-canvas-wrap">
        <canvas id="game"></canvas>
      </div>

      <!-- Popup info page shown when player first stands on the red dot -->
      <div id="popup" class="popup-overlay hidden">
        <div class="popup-content">
          <h3 class="popup-title">å‘¨æ¸…æœˆçš„è¨˜è€…è­‰</h3>
          <div class="popup-body">
            <div class="popup-figure">
              <img src="assets/1_0.png" alt="å‘¨æ¸…æœˆçš„è¨˜è€…è­‰åœ–åƒ" />
              <span>åœ–èªªï¼šå‘¨æ¸…æœˆçš„è¨˜è€…è­‰</span>
            </div>
            <p>æ°‘åœ‹ 70 å¹´ 7 æœˆ 3 æ—¥ï¼Œé™³æ–‡æˆæ•™æˆè¢«ç™¼ç¾é™³å±åœ¨è‡ºç£å¤§å­¸æ ¡å…§ã€‚è€Œå¾Œï¼Œä»–åœ¨ç¾åœ‹å¡å…§åŸºï¼æ¢…éš†å¤§å­¸çš„åŒäº‹â”€â”€æ³•é†«é­å¥‘èˆ‡çµ±è¨ˆç³»ä¸»ä»»ç‹„æ ¼é­¯ä¾†è‡ºï¼Œå°é™³æ–‡æˆä¹‹æ­»é€²è¡Œç¨ç«‹èª¿æŸ¥ã€‚</p>
            <p>é™³æ–‡æˆä¹‹æ­»å¼•èµ·åœ‹å…§å¤–å»£æ³›é—œæ³¨ï¼Œç¾è¯ç¤¾è¨˜è€…å‘¨æ¸…æœˆï¼ˆTina Chouï¼‰æ¡è¨ªé™³æ–‡æˆçš„çˆ¶è¦ªå¾Œï¼Œé‡å°ç‹„æ ¼é­¯èˆ‡é­å¥‘ä¾†è‡ºæ’°å¯«äº†å ±å°ã€‚å› ç‚ºé€™ç¯‡å ±å°ï¼Œå‘¨æ¸…æœˆè¢«æ–°èå±€ä»¥ã€Œåœ¨åœ‹éš›é–“åš´é‡æåŠä¸­è¯æ°‘åœ‹ä¸»æ¬Šèˆ‡æ³•å¾‹çš„å°Šåš´ã€ç‚ºç”±ï¼Œå–æ¶ˆäº†è¨˜è€…è­‰ï¼Œä¸¦ç¦æ­¢å¥¹å¾äº‹ä»»ä½•æ–°èå·¥ä½œã€‚</p>
            <p>å› ç‚ºå ±å°ä¸­æåˆ°é­å¥‘èˆ‡ç‹„æ ¼é­¯ä¾†è‡ºã€Œé©—å±ã€ï¼ˆautopsyï¼‰ï¼Œè€Œæ–°èå±€èªç‚ºå…©äººåƒ…æ˜¯ã€Œæª¢è¦–ã€ï¼ˆviewï¼‰å±é«”ï¼Œä¸¦éã€Œé©—å±ã€ã€‚</p>
          </div>
          <button id="popupClose" class="popup-close" aria-label="é—œé–‰">âœ•</button>
        </div>
      </div>

      <!-- Direction controls: æ”¾åœ¨ layout-main è£¡ï¼Œæ–¹ä¾¿ç›´å‘æ™‚ç›¸å°å…§å®¹ç½®ä¸­ -->
      <div class="controls" id="controls">
        <div></div>
        <div class="btn" data-dir="up">â–²</div>
        <div></div>

        <div class="btn" data-dir="left">â—€</div>
        <div></div>
        <div class="btn" data-dir="right">â–¶</div>

        <div></div>
        <div class="btn" data-dir="down">â–¼</div>
        <div></div>
      </div>
    </div>
  </div>

  <!-- Experience start overlay -->
  <!-- ä¸€é–‹å§‹å…ˆéš±è—ï¼Œä¹‹å¾Œä¾æµç¨‹é¡¯ç¤º -->
  <div class="start-overlay hidden" id="startOverlay">
    <div class="start-card">
      <h1>å³¶å¶¼å€™è»Šå®¤ï¼é–‹å¾€æ°‘ä¸»çš„è½‰å‹æ­£ç¾©åˆ—è»Š</h1>
      <p>é»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å§‹é«”é©—é€™æ®µé—œæ–¼è½‰å‹æ­£ç¾©ã€è¨˜æ†¶èˆ‡å‰è¡Œçš„è»Šç«™æ—…ç¨‹ã€‚</p>
      <button class="start-button" id="startButton">é–‹å§‹é«”é©—</button>
    </div>
  </div>

  <!-- Desktop help button and overlay -->
  <div class="help-button-desktop" id="helpButton">?</div>
  <div class="help-overlay hidden" id="helpOverlay">
    <div class="help-content">
      <h3>é—œæ–¼æœ¬å°ˆæ¡ˆ</h3>
      <p><strong>è½‰å‹æ­£ç¾© Gather Town ç·šä¸Šå±•è¦½ï¼Œä¿ƒè½‰åˆ—è»Šæ¶å…ˆè©¦ä¹˜</strong></p>
      <p>å¦‚æœè½‰å‹æ­£ç¾©ï¼Œæ˜¯ä¸€å°é€šå¾€æ°‘ä¸»æœªä¾†çš„åˆ—è»Šâ€¦â€¦</p>
      <p>ä¿ƒè½‰æœƒçš„æ ¸å¿ƒç†å¿µä¹‹ä¸€ï¼Œæ˜¯å°‡ã€Œè½‰å‹æ­£ç¾©ã€çš„æˆæœèˆ‡ç¤¾æœƒå…±äº«ã€‚é™¤äº†å°‡ä¸‰å¹´ä»¥ä¾†çš„åŠªåŠ›æ•´ç†æˆè©³ç´°å ±å‘Šã€Šä»»å‹™æ¨å‹•åŠèª¿æŸ¥æˆæœå ±å‘Šæ›¸ã€‹ä¹‹å¤–ï¼Œæ›´å¸Œæœ›é€éå¤šå…ƒé€”å¾‘ï¼Œè®“åœ‹äººæ¥è§¸ã€èªè­˜ã€é€²ä¸€æ­¥åƒèˆ‡è½‰å‹æ­£ç¾©ã€‚</p>
      <p>å› æ­¤ä¿ƒè½‰æœƒé€é GatherTownï¼Œä½ˆç½®ç·šä¸Šå±•è¦½ã€Šå³¶å¶¼å€™è»Šå®¤ï¼é–‹å¾€æ°‘ä¸»çš„è½‰å‹æ­£ç¾©åˆ—è»Šã€‹ï¼Œå°‡å ±å‘Šæ›¸çš„å…§å®¹æ¯”å–»æˆã€Œè™›æ“¬ç«è»Šç«™ã€ï¼Œæ­éœ²å£“è¿«é«”åˆ¶è¼ªå»“ã€é‡è¿°æ¬Šå¨ä¸‹å—å®³è€…æ•…äº‹ï¼Œä»¥åŠæç¹ªæœªä¾†è½‰å‹æ­£ç¾©å·¥ç¨‹é¡˜æ™¯ã€‚</p>
      <p>ğŸš‡ ç¾åœ¨åªè¦ç•™è¨€ã€Œè©¦ä¹˜ã€ä¸¦åˆ†äº«æ­¤å‰‡è²¼æ–‡<br>
         ğŸš‡ å°±æœ‰æ©Ÿæœƒæ¶å…ˆåƒèˆ‡é«”é©—ç·šä¸Šå±•è¦½<br>
         ğŸš‡ é‚„æœ‰æ©Ÿæœƒç²å¾—ç‰¹è£½ç²¾ç¾å£ç½©</p>
      <p>é€éä½ çš„ã€Œè¦‹è­‰ã€èˆ‡ã€ŒçºŒå¯«ã€ï¼Œè®“æˆ‘å€‘ä¸€èµ·æˆç‚ºå¾Œäººè¨˜æ†¶ä¸­çš„å‰è¡Œè€…ï¼</p>
      <div class="help-close" id="helpClose">é—œé–‰</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const popup = document.getElementById('popup');
    const popupClose = document.getElementById('popupClose');
    const popupContent = document.querySelector('.popup-content');
    const helpButton = document.getElementById('helpButton');
    const helpOverlay = document.getElementById('helpOverlay');
    const helpClose = document.getElementById('helpClose');
    const startOverlay = document.getElementById('startOverlay');
    const startButton = document.getElementById('startButton');

    // Logical game size; will be updated to match background image dimensions
    // World size (map) and view size (visible screen window in world coordinates)
    let WORLD_WIDTH = 1024;
    let WORLD_HEIGHT = 576;
    let VIEW_WIDTH = 1024;
    let VIEW_HEIGHT = 576;

    // Canvas é¡¯ç¤ºå°ºå¯¸èˆ‡ scaleï¼ˆç”± resizeCanvas è¨­å®šï¼Œä¾› draw ç½®ä¸­ç”¨ï¼‰
    let canvasCssWidth = 0;
    let canvasCssHeight = 0;
    let dpr = 1;
    let currentScale = 1;
    const TILE_SIZE = 32; // grid size for tile-based movement
    const MOVE_SPEED = 240; // pixels per second (frame-independent for consistent speed)

    // Background image of the station.
    // Use the station map image in this folder.
    const bgImage = new Image();

    // Collision mask (black = blocked, non-black = walkable), same size as station image.
    const collisionMask = new Image();
    const maskCanvas = document.createElement('canvas');
    const maskCtx = maskCanvas.getContext('2d');
    let blockedTiles = []; // blockedTiles[row][col] === true => cannot walk

    bgImage.onload = () => {
      // World (map) size = image size
      WORLD_WIDTH = bgImage.naturalWidth;
      WORLD_HEIGHT = bgImage.naturalHeight;

      // åŸºæœ¬è¦–çª—å¯¬åº¦ï¼ˆæ¡Œæ©Ÿç”¨ï¼‰ï¼Œå†ç¸®å°ä¸€äº›ç•¶ä½œã€Œé¡é ­ç¸®æ”¾ã€åŸºæº–
      const baseViewWidth = Math.min(WORLD_WIDTH, 1920);
      const isMobile = window.innerWidth <= 768;

      if (isMobile) {
        // æ‰‹æ©Ÿç›´å¼ï¼šä½¿ç”¨ç›´é•·ç•«é¢æ¯”ä¾‹ï¼ˆç´„ 9:16ï¼‰ï¼Œè®“éŠæˆ²å€æ˜é¡¯è®Šé•·
        const portraitAspect = 360 / 640; // å¯¬/é«˜ï¼Œç•«é¢æ¯”å¯¬æ›´é•·
        VIEW_HEIGHT = WORLD_HEIGHT;
        VIEW_WIDTH = Math.min(WORLD_WIDTH, Math.round(VIEW_HEIGHT * portraitAspect));
        VIEW_WIDTH = Math.max(VIEW_WIDTH, 10 * TILE_SIZE);
      } else {
        // æ¡Œæ©Ÿè¦–è§’ï¼šè¦–çª—åå¯¬å±ï¼Œé¡¯ç¤ºæ›´å¤§ç‰‡æ°´å¹³å…§å®¹ï¼Œä½†ä¸æ‹‰ä¼¸ç•«é¢ï¼Œåªæ˜¯è£æ‰ä¸€é»ä¸Šä¸‹
        const desktopAspect = 2.1; // ç´„ 21:10ï¼Œæ¯”åŸå§‹ 16:9 æ›´å¯¬
        VIEW_WIDTH = baseViewWidth * 0.78;
        VIEW_HEIGHT = VIEW_WIDTH / desktopAspect;
      }

      updateLogicalPositions();
      resizeCanvas();

      // å¦‚æœé®ç½©å·²è¼‰å…¥ï¼Œå»ºç«‹ç¢°æ’è³‡æ–™
      if (collisionMask.complete && collisionMask.naturalWidth > 0) {
        prepareCollisionMask();
      }
    };

    // é®ç½©è¼‰å…¥å®Œæˆå¾Œï¼Œå¦‚æœèƒŒæ™¯å°ºå¯¸å·²çŸ¥ï¼Œå»ºç«‹ç¢°æ’è³‡æ–™
    collisionMask.onload = () => {
      if (WORLD_WIDTH > 0 && WORLD_HEIGHT > 0) {
        prepareCollisionMask();
      }
    };

    // Map images are now placed in the maps/ folder.
    // If you rename them, just update these paths accordingly.
    bgImage.src = 'maps/station.jpg';
    collisionMask.src = 'maps/station_mask.png';

    // Small journalist card icon placed on the map at the red dot.
    const cardIdleImage = new Image();
    const cardActiveImage = new Image();
    // Idle and "nearby" versions of the reporter ID icon.
    cardIdleImage.src = 'assets/1_0.png';
    cardActiveImage.src = 'assets/2_0.png';

    // Player directional sprites (32x32). Put these PNGs in the same folder.
    const playerSprites = {
      up: new Image(),
      down: new Image(),
      left: new Image(),
      right: new Image()
    };
    playerSprites.up.src = 'characters/player_up.png';
    playerSprites.down.src = 'characters/player_down.png';
    playerSprites.left.src = 'characters/player_left.png';
    playerSprites.right.src = 'characters/player_right.png';

    // Fractions for important positions based on the station map.
    // PLAYER_POS is only used for initial band; exact start will be bottom-left of walkable area.
    const PLAYER_POS = { x: 0.1, y: 0.75 };
    const ZONE_POS = { x: 0.5, y: 0.42, w: 40, h: 30 };

    // Player: 32x64ï¼ˆå¯¬ä¸€æ ¼ã€é«˜å…©æ ¼ï¼‰çš„äººç‰©.
    const player = {
      x: WORLD_WIDTH * PLAYER_POS.x,
      y: WORLD_HEIGHT * PLAYER_POS.y,
      width: TILE_SIZE,        // 32px
      height: TILE_SIZE * 2,   // 64px
      moving: false,
      targetX: 0,
      targetY: 0,
      remainingDist: 0,
      speed: MOVE_SPEED,
      dir: 'down' // current facing direction: 'up' | 'down' | 'left' | 'right'
    };

    // Single interaction point: where the character is standing on the screenshot.
    // You can fineâ€‘tune these numbers later.
    const interactionZone = {
      x: WORLD_WIDTH * ZONE_POS.x - ZONE_POS.w / 2,
      y: WORLD_HEIGHT * ZONE_POS.y - ZONE_POS.h / 2,
      width: ZONE_POS.w,
      height: ZONE_POS.h,
      info: 'This is the key interaction point on the platform.'
    };

    const keys = { up: false, down: false, left: false, right: false };
    let wasInZone = false;
    let isInZoneNow = false;
    let isNearZoneNow = false;

    // Camera: å·¦ä¸Šè§’ä¸–ç•Œåº§æ¨™ï¼›viewW/viewH ç‚ºå¯¦éš›å¯è¦–ç¯„åœï¼ˆcover æ™‚ = screen/scaleï¼‰
    const camera = { x: 0, y: 0, viewW: VIEW_WIDTH, viewH: VIEW_HEIGHT };

    // --- ç¬¬ä¸€æ­¥ï¼šæ­£ç¢º resize canvasï¼ˆå« devicePixelRatioï¼Œä¸æ‹‰ä¼¸ï¼‰---
    function getGameCanvasContainerSize() {
      var w = window.innerWidth;
      var wrap = document.getElementById('game-canvas-wrap');
      var h = (wrap && wrap.clientHeight > 0) ? wrap.clientHeight : window.innerHeight;
      return { width: w, height: h };
    }

    function resizeCanvas() {
      dpr = window.devicePixelRatio || 1;
      var size = getGameCanvasContainerSize();
      var screenW = Math.max(1, size.width);
      var screenH = Math.max(1, size.height);

      var DESIGN_W = VIEW_WIDTH;
      var DESIGN_H = VIEW_HEIGHT;
      var scale = Math.max(screenW / DESIGN_W, screenH / DESIGN_H);

      var drawW = DESIGN_W * scale;
      var drawH = DESIGN_H * scale;

      camera.viewW = screenW / scale;
      camera.viewH = screenH / scale;
      currentScale = scale;

      canvas.style.width = drawW + 'px';
      canvas.style.height = drawH + 'px';

      canvas.width = Math.floor(drawW * dpr);
      canvas.height = Math.floor(drawH * dpr);

      ctx.setTransform(dpr * scale, 0, 0, dpr * scale, 0, 0);

      canvasCssWidth = drawW;
      canvasCssHeight = drawH;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const gameCanvasWrap = document.getElementById('game-canvas-wrap');
    if (gameCanvasWrap && typeof ResizeObserver !== 'undefined') {
      new ResizeObserver(resizeCanvas).observe(gameCanvasWrap);
    }

    function updateLogicalPositions() {
      // Define a walkable band that roughly matches the green floor of the platform.
      // Character should startåœ¨æœˆå°åå·¦ä¸­é–“çš„ä½ç½®ï¼ˆé¿é–‹æœ€å·¦å´é®ç½©å€åŸŸï¼‰ã€‚
      const walkTop = WORLD_HEIGHT * 0.63;
      const walkBottom = WORLD_HEIGHT * 0.86;

      // Start a bit more to the rightã€ç¨å¾®æ›´é ä¸‹çš„ä½ç½®ã€‚
      player.x = TILE_SIZE * 4.5;
      player.y = (walkTop + walkBottom) / 2;

      // Interaction zone stays roughly in the middle of the platform.
      interactionZone.x = WORLD_WIDTH * ZONE_POS.x - ZONE_POS.w / 2;
      interactionZone.y = WORLD_HEIGHT * ZONE_POS.y - ZONE_POS.h / 2;

      // Cache walk band for collision checks.
      player.walkTop = walkTop;
      player.walkBottom = walkBottom;
    }

    updateLogicalPositions();

    // åˆ©ç”¨é®ç½©åœ–ç‰‡å»ºç«‹ blockedTilesï¼šé»‘è‰²(æ¥è¿‘ #000) è¦–ç‚ºä¸å¯é€šè¡Œ
    function prepareCollisionMask() {
      maskCanvas.width = WORLD_WIDTH;
      maskCanvas.height = WORLD_HEIGHT;
      maskCtx.clearRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
      maskCtx.drawImage(collisionMask, 0, 0, WORLD_WIDTH, WORLD_HEIGHT);

      const cols = Math.ceil(WORLD_WIDTH / TILE_SIZE);
      const rows = Math.ceil(WORLD_HEIGHT / TILE_SIZE);
      blockedTiles = new Array(rows);

      const imgData = maskCtx.getImageData(0, 0, WORLD_WIDTH, WORLD_HEIGHT).data;

      for (let row = 0; row < rows; row++) {
        blockedTiles[row] = new Array(cols).fill(false);
        for (let col = 0; col < cols; col++) {
          // å–è©²æ ¼ä¸­å¿ƒé»çš„é¡è‰²
          const sampleX = Math.min(
            WORLD_WIDTH - 1,
            Math.floor(col * TILE_SIZE + TILE_SIZE / 2)
          );
          const sampleY = Math.min(
            WORLD_HEIGHT - 1,
            Math.floor(row * TILE_SIZE + TILE_SIZE / 2)
          );
          const idx = (sampleY * WORLD_WIDTH + sampleX) * 4;
          const r = imgData[idx];
          const g = imgData[idx + 1];
          const b = imgData[idx + 2];
          const a = imgData[idx + 3];

          // ä¸é€æ˜ä¸”éå¸¸æ¥è¿‘é»‘è‰² => è¦–ç‚ºç‰†
          if (a > 0 && r < 10 && g < 10 && b < 10) {
            blockedTiles[row][col] = true;
          }
        }
      }
    }

    // --- Tile-based movement helpers ---
    function tryMove(dxTiles, dyTiles) {
      const dx = dxTiles * TILE_SIZE;
      const dy = dyTiles * TILE_SIZE;
      if (dx === 0 && dy === 0) return;
      if (player.moving) return; // wait until current step finishes

      let newX = player.x + dx;
      let newY = player.y + dy;

      const halfW = player.width / 2;
      const halfH = player.height / 2;

      // Clamp to world bounds
      newX = Math.max(halfW, Math.min(WORLD_WIDTH - halfW, newX));
      newY = Math.max(halfH, Math.min(WORLD_HEIGHT - halfH, newY));

      // ä¾ç…§é®ç½©åˆ¤æ–·ç›®æ¨™æ ¼æ˜¯å¦è¢«å°é–
      if (blockedTiles.length > 0) {
        const col = Math.floor(newX / TILE_SIZE);
        const row = Math.floor(newY / TILE_SIZE);
        if (
          row >= 0 &&
          row < blockedTiles.length &&
          col >= 0 &&
          col < blockedTiles[0].length &&
          blockedTiles[row][col]
        ) {
          // ç›®æ¨™æ˜¯é»‘è‰²å€å¡Šï¼Œå–æ¶ˆé€™ä¸€æ­¥
          return;
        }
      }

      const dist = Math.hypot(newX - player.x, newY - player.y);
      if (dist === 0) return;

      // Set up smooth movement towards the target tile
      player.targetX = newX;
      player.targetY = newY;
      player.remainingDist = dist;
      player.moving = true;
    }

    function moveFromDirection(dir) {
      switch (dir) {
        case 'up':
          player.dir = 'up';
          tryMove(0, -1); break;
        case 'down':
          player.dir = 'down';
          tryMove(0, 1); break;
        case 'left':
          player.dir = 'left';
          tryMove(-1, 0); break;
        case 'right':
          player.dir = 'right';
          tryMove(1, 0); break;
      }
    }

    // Keyboard input: keep direction pressed while key held down
    window.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          keys.up = true; break;
        case 'ArrowDown':
        case 's':
        case 'S':
          keys.down = true; break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          keys.left = true; break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          keys.right = true; break;
      }
    });

    window.addEventListener('keyup', (e) => {
      switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          keys.up = false; break;
        case 'ArrowDown':
        case 's':
        case 'S':
          keys.down = false; break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          keys.left = false; break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          keys.right = false; break;
      }
    });

    const controls = document.getElementById('controls');

    // Touch / mouse buttons: hold to keep moving in that directionï¼ˆå”¯ä¸€ä¸€çµ„æ–¹å‘éµï¼šHTML .controlsï¼‰
    if (controls) {
      controls.querySelectorAll('.btn').forEach(btn => {
        const dir = btn.dataset.dir;

        const start = (e) => {
          e.preventDefault();
          btn.classList.add('active');
          keys[dir] = true;
        };

        const end = (e) => {
          e.preventDefault();
          btn.classList.remove('active');
          keys[dir] = false;
        };

        btn.addEventListener('touchstart', start, { passive: false });
        btn.addEventListener('touchend', end, { passive: false });
        btn.addEventListener('touchcancel', end, { passive: false });

        btn.addEventListener('mousedown', start);
        window.addEventListener('mouseup', end);
      });
    }

    function update(dt) {
      player.dt = dt;
      // If not currently moving to a tile, check held directions and start a new step.
      if (!player.moving) {
        let dir = null;
        if (keys.up) dir = 'up';
        else if (keys.down) dir = 'down';
        else if (keys.left) dir = 'left';
        else if (keys.right) dir = 'right';

        if (dir) {
          moveFromDirection(dir);
        }
      }

      // Smoothly move player towards target tile if currently moving (delta-time based)
      if (player.moving) {
        const dx = player.targetX - player.x;
        const dy = player.targetY - player.y;
        const dist = Math.hypot(dx, dy);
        const step = player.speed * (player.dt ?? 1/60); // pixels this frame

        if (dist <= step || dist === 0) {
          // Snap to tile and finish movement
          player.x = player.targetX;
          player.y = player.targetY;
          player.moving = false;
          player.remainingDist = 0;
        } else {
          const stepX = (dx / dist) * step;
          const stepY = (dy / dist) * step;
          player.x += stepX;
          player.y += stepY;
          player.remainingDist = dist - step;
        }
      }

      // Keep player inside the world bounds
      const halfW = player.width / 2;
      const halfH = player.height / 2;
      player.x = Math.max(halfW, Math.min(WORLD_WIDTH - halfW, player.x));
      player.y = Math.max(halfH, Math.min(WORLD_HEIGHT - halfH, player.y));

      // Camera è·Ÿéš¨ç©å®¶ä¸­å¿ƒï¼Œä¸¦ clamp ä¸è¶…å‡ºåœ°åœ–
      var viewW = camera.viewW;
      var viewH = camera.viewH;
      camera.x = player.x + player.width / 2 - viewW / 2;
      camera.y = player.y + player.height / 2 - viewH / 2;
      camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - viewW));
      camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - viewH));

      // Distance between player and the center of the interaction object
      const objCenterX = interactionZone.x + interactionZone.width / 2;
      const objCenterY = interactionZone.y + interactionZone.height / 2;
      const dxCenter = player.x - objCenterX;
      const dyCenter = player.y - objCenterY;
      const distToCenter = Math.hypot(dxCenter, dyCenter);

      // "Near" definition: close to the icon but not necessarily inside the trigger zone yet
      isNearZoneNow = distToCenter < 90;

      // Interaction detection: show HTML popup overlay when player fully enters the small zone
      const inZone = isPlayerInZone(player, interactionZone);
      isInZoneNow = inZone;
      if (inZone && !wasInZone) {
        popup.classList.remove('hidden');
      } else if (!inZone && wasInZone) {
        popup.classList.add('hidden');
      }
      wasInZone = inZone;
    }

    // --- ç­‰æ¯”ä¾‹ç¹ªè£½ï¼ˆcover æ¨¡å¼ï¼‰ï¼šä¸–ç•Œåº§æ¨™ translateï¼Œå¯è¦–ç¯„åœ = camera.viewW / viewH ---
    function draw() {
      var viewW = camera.viewW;
      var viewH = camera.viewH;
      if (viewW <= 0 || viewH <= 0) return;

      ctx.clearRect(0, 0, canvasCssWidth, canvasCssHeight);

      var offsetX = canvasCssWidth / 2 - viewW * currentScale / 2 - camera.x;
      var offsetY = canvasCssHeight / 2 - viewH * currentScale / 2 - camera.y;

      ctx.save();
      ctx.translate(offsetX, offsetY);

      if (bgImage.complete && bgImage.naturalWidth > 0) {
        ctx.drawImage(bgImage, 0, 0, WORLD_WIDTH, WORLD_HEIGHT, 0, 0, WORLD_WIDTH, WORLD_HEIGHT);
      } else {
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
      }

      var objX = interactionZone.x + interactionZone.width / 2;
      var objY = interactionZone.y + interactionZone.height / 2;

      if (isNearZoneNow || isInZoneNow) {
        var t = Date.now() / 300;
        var pulse = (Math.sin(t) + 1) / 2;
        var baseRadius = isInZoneNow ? 30 : 22;
        var extra = isInZoneNow ? 10 : 6;
        var radius = baseRadius + extra * pulse;
        var gradient = ctx.createRadialGradient(
          objX, objY, 4,
          objX, objY, radius
        );
        gradient.addColorStop(0, 'rgba(255, 255, 180, 0.9)');
        gradient.addColorStop(1, 'rgba(255, 255, 180, 0)');

        ctx.save();
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(objX, objY, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      var cardWidth = 60;
      var cardHeight = 60;
      var useActive = isNearZoneNow || isInZoneNow;
      var icon = useActive ? cardActiveImage : cardIdleImage;
      if (icon.complete && icon.naturalWidth > 0) {
        ctx.drawImage(
          icon,
          objX - cardWidth / 2,
          objY - cardHeight / 2,
          cardWidth,
          cardHeight
        );
      } else {
        ctx.save();
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(objX, objY, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      drawPlayer({
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      });

      ctx.restore();
    }

    let lastFrameTime = 0;
    function loop(now) {
      now = now ?? performance.now();
      if (lastFrameTime === 0) lastFrameTime = now;
      const dt = Math.min((now - lastFrameTime) / 1000, 0.1); // seconds, cap to avoid jump after tab focus
      lastFrameTime = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function drawPlayer(p) {
      const halfW = p.width / 2;
      const halfH = p.height / 2;
      const x = p.x - halfW;
      const y = p.y - halfH;

      const sprite = playerSprites[player.dir];
      if (sprite && sprite.complete && sprite.naturalWidth > 0) {
        // Use directional sprite image with a soft glow
        ctx.save();
        ctx.shadowColor = 'rgba(255, 255, 200, 0.8)';
        ctx.shadowBlur = 15;
        ctx.drawImage(sprite, x, y, p.width, p.height);
        ctx.restore();
        return;
      }

      // Fallback: simple placeholder if sprites not found
      ctx.fillStyle = '#3b7cff';
      ctx.fillRect(x + p.width * 0.2, y + p.height * 0.3, p.width * 0.6, p.height * 0.5);

      const headRadius = p.width * 0.3;
      ctx.fillStyle = '#ffddaa';
      ctx.beginPath();
      ctx.arc(p.x, y + headRadius + 2, headRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(p.x - p.width * 0.15, y + p.height * 0.8);
      ctx.lineTo(p.x - p.width * 0.15, y + p.height);
      ctx.moveTo(p.x + p.width * 0.15, y + p.height * 0.8);
      ctx.lineTo(p.x + p.width * 0.15, y + p.height);
      ctx.stroke();
    }

    function isPlayerInZone(p, zone) {
      const halfW = p.width / 2;
      const halfH = p.height / 2;
      const left = p.x - halfW;
      const right = p.x + halfW;
      const top = p.y - halfH;
      const bottom = p.y + halfH;

      return !(
        right < zone.x ||
        left > zone.x + zone.width ||
        bottom < zone.y ||
        top > zone.y + zone.height
      );
    }

    // Start loop immediately; background will appear once loaded.
    loop();

    // --- Popup behavior ---
    function hidePopup() {
      popup.classList.add('hidden');
    }

    popup.addEventListener('click', hidePopup);
    popupClose.addEventListener('click', (e) => {
      e.stopPropagation();
      hidePopup();
    });
    popupContent.addEventListener('click', (e) => {
      // Prevent clicks on content from closing via overlay handler
      e.stopPropagation();
    });

    // --- Help overlay behavior (desktop) ---
    helpButton.addEventListener('click', () => {
      helpOverlay.classList.remove('hidden');
    });
    helpClose.addEventListener('click', () => {
      helpOverlay.classList.add('hidden');
    });
    helpOverlay.addEventListener('click', () => {
      helpOverlay.classList.add('hidden');
    });

    // --- Start overlay behavior ---
    let hasShownStart = false;
    function showStartOverlayIfNeeded() {
      if (!hasShownStart) {
        startOverlay.classList.remove('hidden');
        hasShownStart = true;
      }
    }
    function hideStartOverlay() {
      startOverlay.classList.add('hidden');
    }
    startButton.addEventListener('click', hideStartOverlay);
    startOverlay.addEventListener('click', hideStartOverlay);

    showStartOverlayIfNeeded();
  </script>
</body>
</html>

